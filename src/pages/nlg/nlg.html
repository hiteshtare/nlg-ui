<ion-header>
  <ion-navbar>
    <ion-title>
      Natural Language Generation (usecase: bot conversations)
    </ion-title>
  </ion-navbar>
</ion-header>
<ion-content padding>
  <ion-grid>
    <ion-row>
      <ion-col>
        <div>
          <ion-item>
            <ion-label floating>No Of Samples : {{this.noOfSamples}}</ion-label>
            <ion-input [(ngModel)]="noOfSamples"></ion-input>
          </ion-item>
          <div [formGroup]="form">
            <div *ngFor="let control of controls" class="form-row">
              <dynamic-control [input]="control" [form]="form">
              </dynamic-control>
            </div>
            <div class="form-row">
              <button ion-button type="button" [disabled]="!form.valid" (click)="onSubmit(form.value)">generate</button>
              <!-- <button type="submit" class="btn btn-success" [disabled]="!form.valid">Save</button> -->
            </div>
          </div>
          <!-- <pre>{{form.valid | json }}</pre> -->
          <!-- <pre>{{form.value | json }}</pre> -->
          <!-- <div *ngIf="payLoad" class="form-row">
            <strong>Saved the following values</strong>
            <br>{{payLoad}}
          </div>
          <p>Submitted data: </p>
          <pre>{{ submittedData | json }}</pre> -->
        </div>
        <br>
        <hr>
        <form [formGroup]="ionInputForm" (ngSubmit)="manage(ionInputForm.value)">
          <ion-list margin-bottom>
            <!-- Assign the technologies FormArray to the form
              where we want to track/generate new input track fields -->
            <div formArrayName="technologies" margin-bottom>


              <!-- Assign a FormGroupName property binding to track
                 and manage each separate generated input field.
                 Also iterate through the technologies FormArray to
                 correctly track/render new input fields against
                 existing fields -->
              <section [formGroupName]="i" *ngFor="let tech of ionInputForm.controls.technologies.controls; let i = index">
                <ion-item-group>
                  <ion-item-divider color="light">Keyword #{{ i + 1 }}</ion-item-divider>
                  <ion-item>
                    <ion-label floating>Keyword :</ion-label>
                    <ion-input type="text" maxlength="50" formControlName="name"></ion-input>
                  </ion-item>


                  <!-- Allow generated input field to be removed -->
                  <span float-right ion-button icon-left clear *ngIf="ionInputForm.controls.technologies.length > 1"
                    (click)="removeInputField(i)">
                    <ion-icon name="close"></ion-icon>
                    Remove
                  </span>
                </ion-item-group>
              </section>
            </div>


            <!-- Allow new input field to be generated/added -->
            <span ion-button float-left icon-left clear (click)="addNewInputField()">
              <ion-icon name="add"></ion-icon>
              Add a new Keyword
            </span>


          </ion-list>


          <!-- Only allow form to be submitted IF validation criteria for
              input fields has been successfully passed -->
          <button ion-button block margin-top color="primary" text-center [disabled]="!ionInputForm.valid">Submit</button>
        </form>
      </ion-col>
      <ion-col>
        <div class="right">
          <ion-label color="dark">The consolidated document is</ion-label>
          <div *ngIf="name == '' && date == '' && time == '' && subject == ''">
            <li *ngFor="let int of nameStr">{{int}} </li>
          </div>
          <div *ngIf="name !== '' && date !== '' && time !== '' && subject !== ''">
            <li *ngFor="let int of dateStr">{{int}}</li>
          </div>
          <div *ngIf="intent === 'Search'">
            <li *ngFor="let int of dateStr">{{int}}</li>
          </div>
        </div>
      </ion-col>
    </ion-row>
    <ion-row>
      <!-- <ion-col> -->
      <!-- Assign the FormGroup of form to the HTML form
        via a property binding (allowing the component
        class to communicate/interact with the template -->

      <!-- </ion-col> -->
    </ion-row>
  </ion-grid>

</ion-content>
